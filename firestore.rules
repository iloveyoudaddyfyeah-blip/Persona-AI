/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model.  Each user can only
 * access their own data.  This includes user profiles, character profiles,
 * chat sessions, and chat messages.
 *
 * Data Structure:
 * The data is organized hierarchically under `/users/{userId}`.
 *  - `/users/{userId}`: Stores user profile information.
 *  - `/users/{userId}/characters/{characterId}`: Stores character profiles
 *    created by the user.
 *  - `/users/{userId}/characters/{characterId}/chatSessions/{chatSessionId}`:
 *    Stores chat sessions for a specific character profile.
 *  - `/users/{userId}/characters/{characterId}/chatSessions/{chatSessionId}/chatMessages/{chatMessageId}`:
 *    Stores chat messages for a specific chat session.
 *
 * Key Security Decisions:
 * - User listing is disallowed to prevent enumeration.
 * - All write operations are protected by authorization checks to ensure that
 *   only the owner can modify data.
 * - In this prototype phase, data schema validation is relaxed to allow for rapid iteration,
 *   but authorization checks are strictly enforced.
 *
 * Denormalization for Authorization:
 * The `userId` is included in the `CharacterProfile` object, enabling rules to verify the user's access without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create, update, get, delete, list) User with matching ID.
     * @deny (create, update, delete) User with non-matching ID.
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // No listing of users.

      // Allow the user to create their own profile, enforcing that the userId in the document matches the path.
      allow create: if isOwner(userId) && request.resource.data.id == userId;

      // Allow updates and deletes only if the user is the owner and the document exists.
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; //Enforce immutability of the id (userId)

      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/characters/{characterId} collection.
     * @path /users/{userId}/characters/{characterId}
     * @allow (create, update, get, delete, list) User with matching userId and characterId.
     * @deny (create, update, delete) User with non-matching userId or characterId.
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId}/characters/{characterId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId; //Enforce immutability of the userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/characters/{characterId}/chatSessions/{chatSessionId} collection.
     * @path /users/{userId}/characters/{characterId}/chatSessions/{chatSessionId}
     * @allow (create, update, get, delete, list) User with matching userId, characterId and chatSessionId.
     * @deny (create, update, delete) User with non-matching userId, characterId or chatSessionId.
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId}/characters/{characterId}/chatSessions/{chatSessionId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

        function isExistingOwner(userId) {
            return isOwner(userId) && resource != null;
        }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/characters/{characterId}/chatSessions/{chatSessionId}/chatMessages/{chatMessageId} collection.
     * @path /users/{userId}/characters/{characterId}/chatSessions/{chatSessionId}/chatMessages/{chatMessageId}
     * @allow (create, update, get, delete, list) User with matching userId, characterId, chatSessionId and chatMessageId.
     * @deny (create, update, delete) User with non-matching userId, characterId, chatSessionId or chatMessageId.
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId}/characters/{characterId}/chatSessions/{chatSessionId}/chatMessages/{chatMessageId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

        function isExistingOwner(userId) {
            return isOwner(userId) && resource != null;
        }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}